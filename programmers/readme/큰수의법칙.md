# 큰 수의 법칙
> 쉬움
>
> 2020-01-31
>
> 2019 국가 교육기관 코딩 테스트


<br>

<details>
<summary>문제 설명</summary>
<div markdown="1">       


'큰 수의 법칙'은 일반적으로 통계 분야에서 다루어지는 내용이지만 동빈이는 본인만의 방식으로 다르게 사용하고 있다.  
동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다.  
단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
 
 
예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자.  
이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5인 46이 된다.  
 
 
단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.  
예를 들어 순서대로 3, 4, 3, 4, 3으로 이루어진 배열이 있을 때 M이 7이고, K가 2라고 가정하자.  
이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다.  
결과적으로 4+4+4+4+4+4+4인 28이 도출된다.

 
배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오. 
 
입력 조건 
- 첫째 줄에 N(2<=N<=1000), M(1<=M<=10,000), K(1<=K<=10,000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10,000 이하의 수로 주어진다.
- 입력으로 주어지는 K는 항상 M보다 작거나 같다. 
 
 
출력 조건
- 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

<details>
<summary>입력 예시</summary>
<div markdown="1">       
 

5 8 3
2 4 5 4 6
</div>
</details>


<details>
<summary>출력 예시</summary>
<div markdown="1">        

46
</div>
</details>


</div>
</details>


<br>

### Sol

항상 가장 큰 수를 도출하려면 `주어진 N개의 자연수 중 가장 큰 수를 k번 더한 뒤 두번째로 큰 수를 한 번 더해주는 연산`을 반복하면 된다.  
이 로직을 그대로 코드로 구현하게 되면 다음과 같다.


```python
n,m,k = map(int, input().split())
data = list(map(int,input().split()))

data.sort()
first = data[-1]
second = data[-2]

result = 0

while m != 0:
  result += first * k
  m -= k
  result += second
  m -= 1

print(result)
```
하지만 이 코드는 M이 100억 이상처럼 커진다면 시간 초과 판정을 받을 수 있기에 `반복되는 수열`의 규칙을 찾아서 코드를 단순화 해보았다.  
N개의 자연수가 2 4 5 4 6 이고 k가 3이라면 반복되는 수열은 [6,6,6,5]일 것이다.  
따라서 가장 큰 수열은 k+1길이만큼 (m//(k+1))번 반복되고 (m//(k+1))의 나머지는 k 이하 이므로 가장 큰 숫자(6)를 나머지만큼 더해주면 된다는 것을 알 수 있다.


아래는 그렇게 새로운 로직으로 완성된 코드이다.


```python
n,m,k = map(int, input().split())
data = list(map(int,input().split()))

data.sort()
first = data[-1]
second = data[-2]

repeat = (first * k)+second
count = m // (k+1)
result = (repeat * count) + (first * (m - count*(k+1)))

print(result)
```