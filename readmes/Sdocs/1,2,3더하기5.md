# 1,2,3 더하기 5
> **Silver 3**
>
> **2021-07-28**
>
> [B15990](https://www.acmicpc.net/problem/15990)

## Sol

3과 같지만, 같은 수를 두 번 이상 연속해서 사용하면 안된다.
3에서의 점화식을 다음과 같이 수정

* D[i][j] = i를 1,2,3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j
* D[i][1] = D[i-1][2] + D[i-1][3]
> i에 1을 더해서 목적숫자가 되기 위해서는   
> i에서 1을 뺀 숫자를 만들 수 있는 방법의 수를 구하면 된다.  
> i가 10일 경우 마지막 숫자가 2로 끝나며 9를 만들 수 있는 경우의 수 + 마지막 숫자가 3으로 끝나며 9를 만들 수 있는 경우의 수  

* D[i][2] = D[i-2][1] + D[i-2][3]
* D[i][3] = D[i-3][1] + D[i-3][2]


## 답안
```swift
let n = Int(readLine()!)!
let limit = 100000
let mod = 1000000009
var d = Array(repeating: Array(repeating: 0, count: 4), count: limit+1)

for i in 1...limit {
  if i-1 >= 0 {
    d[i][1] = d[i-1][2] + d[i-1][3]
    if i == 1 {
      d[i][1] = 1 
      // 1로 끝나면서 1을 만들 수 있는건 {1} 한가지
    }
    d[i][1] %= mod
  }
  if i-2 >= 0 {
    d[i][2] = d[i-2][1] + d[i-2][3]
    if i == 2 {
      d[i][2] = 1 
      // 2로 끝나면서 2를 만들 수 있는건 {2} 한가지
    }
    d[i][2] %= mod
  }
  if i-3 >= 0 {
    d[i][3] = d[i-3][1] + d[i-3][2]
    if i == 3 {
      d[i][3] = 1 
      // 3으로 끝나면서 3을 만들 수 있는건 {3} 한가지
    }
    d[i][3] %= mod
  }
}

for _ in 0..<n {
  let num = Int(readLine()!)!
  print((d[num].reduce(0){$0+$1})%mod)
}
```