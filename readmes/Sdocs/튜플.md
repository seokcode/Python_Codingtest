# 튜플
> **19' kakao 개발자 겨울 인턴십**   
> [카카오 겨울 인턴십 문제 해설](https://tech.kakao.com/2020/04/01/2019-internship-test/)
>
> **Lv2**
>
> **2021-03-26**
>
> [프로그래머스: 64065](https://programmers.co.kr/learn/courses/30/lessons/64065)


## Sol

문제의 이해가 조금 어려웠었다.

```xml
튜플은 다음과 같은 성질을 가지고 있습니다.  
1. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
2. 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)
3. 튜플의 원소 개수는 유한합니다.

원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, ..., an)이 주어질 때(단, a1, a2, ..., an은 자연수), 이는 다음과 같이 집합 기호 '{', '}'를 이용해 표현할 수 있습니다.
    * {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}}

예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는
    * {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로
    * {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
    * {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}
    * {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}
는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.

특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.
```
 
 * {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
 * {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
 * {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}
 * {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}

이게 왜 다 같은 튜플인고 하니..! 튜플의 집합 내에서는 순서가 상관없다는 뜻이었다. 저 집합에서 본래의 튜플을 도출해내려면  가장 많이 쓰인 숫자의 순서대로 튜플을 구성하면 된다.  
따라서 `['2': 4, '1': 3, '3': 2, '4':1]` 이므로 `[2,1,3,4]`의 답이 나오는 것을 알 수 있다.


`1번 풀이`  
1번 풀이는 set함수의 substracting(차집합을) 활용하여 문제를 해결하였다. 배열 속 집합의 원소 갯수 순으로 정렬이 되어 있기 때문에 차집합을 통해 중복되는 원소를
제거해가며 튜플에 추가해줄 수 있었다.

`2번 풀이`  
2번 풀이는 Dictionary를 이용하여 1번 풀이와 마찬가지로 정렬을 한 뒤, 딕셔너리에 있는 값이면 추가하지 않는 식으로 해결하였다.  

 
## 답안1 : 차집합 풀이
```swift
func solution(_ s:String) -> [Int] {
    var result = [Int]()
    var sets = s.split(omittingEmptySubsequences: true, whereSeparator: { "}".contains($0) }).map {
        $0.split(omittingEmptySubsequences: true, whereSeparator: { "{,".contains($0) }).map { Int($0)! }
    }
    // print(sets) //[[2], [2, 1], [2, 1, 3], [2, 1, 3, 4]]

    sets.sort { (lhs, rhs) -> Bool in
        lhs.count < rhs.count
    }

    sets.forEach {
        // 차집합
        result.append((Set($0).subtracting(result)).first!)
    }

   return result
}
```

## 답안2 : 딕셔너리 풀이
```swift
import Foundation

func solution(_ s:String) -> [Int] {
    var result = [Int]()
    let sets = s.split(omittingEmptySubsequences: true, whereSeparator: { "}".contains($0) }).map {
        $0.split(omittingEmptySubsequences: true, whereSeparator: { "{,".contains($0) }).map { Int($0)! }
    }.sorted{ (ele1, ele2) -> Bool in
        return ele1.count < ele2.count
    }
    // print(sets) //[[2], [2, 1], [2, 1, 3], [2, 1, 3, 4]]

    var dict = [Int : Int]()

    for i in sets{
      for j in i{
        if dict[j] == nil {
          result.append(j)
          dict[j] = 1
        }
      }
    }

   print(result)
   return result
}
```